---
tags: 50.004
---
[[Algo]]
[[2SAT solver]]

[Aspvall, Plass & Tarjan (1979)](https://en.wikipedia.org/wiki/2-satisfiability#CITEREFAspvallPlassTarjan1979) found a simpler linear time procedure for solving 2-satisfiability instances, based on the notion of [strongly connected components](https://en.wikipedia.org/wiki/Strongly_connected_component "Strongly connected component") from [graph theory](https://en.wikipedia.org/wiki/Graph_theory "Graph theory").

Two vertices in a directed [[Graphs|graph]] are said to be **strongly connected** to each other if there is a directed path from one to the other and vice versa. This is an [equivalence relation](https://en.wikipedia.org/wiki/Equivalence_relation "Equivalence relation"), and the vertices of the graph may be partitioned into strongly connected components, subsets within which every two vertices are strongly connected. There are several efficient linear time algorithms for finding the strongly connected components of a graph, based on [depth first search](https://en.wikipedia.org/wiki/Depth_first_search "Depth first search"): [Tarjan's strongly connected components algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm "Tarjan's strongly connected components algorithm")) and the [path-based strong component algorithm](https://en.wikipedia.org/wiki/Path-based_strong_component_algorithm "Path-based strong component algorithm") each perform a single depth first search. [Kosaraju's algorithm](https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm "Kosaraju's algorithm") performs two depth first searches, but is very simple.

In terms of the [[Implication Graph]], two literals belong to the same strongly connected component whenever *there exist chains of implications from one literal to the other and vice versa*. Therefore, the two literals must have the same value in any satisfying assignment to the given 2-satisfiability instance. In particular, if a variable and its negation both belong to the same strongly connected component, the instance cannot be satisfied, because it is impossible to assign both of these literals the same value. As Aspvall et al. showed, this is a [necessary and sufficient condition](https://en.wikipedia.org/wiki/Necessary_and_sufficient_condition "Necessary and sufficient condition"): a 2-CNF formula is satisfiable if and only if there is no variable that belongs to the same strongly connected component as its negation.

This immediately leads to a linear time algorithm for testing satisfiability of 2-CNF formulae: simply perform a strong connectivity analysis on the implication graph and check that each variable and its negation belong to different components. However, as Aspvall et al. also showed, it also leads to a linear time algorithm for finding a satisfying assignment, when one exists. Their algorithm performs the following steps:

-   *Construct the implication graph* of the instance, and *find its strongly connected components* using any of the known linear-time algorithms for strong connectivity analysis.
-   Check whether any strongly connected component *contains both a variable and its negation*. If so, report that the instance is not satisfiable and halt.
-   Construct the [condensation](https://en.wikipedia.org/wiki/Strongly_connected_component "Strongly connected component") of the implication graph, a smaller graph that has *one vertex for each strongly connected component*, and an *edge* from component _i_ to component _j_ whenever the implication graph contains an edge _uv_ such that _u_ belongs to component _i_ and _v_ belongs to component _j_. The condensation is automatically a [[Directed acyclic graph (DAG)]] and, like the [[Implication Graph]] from which it was formed, it is [skew-symmetric](https://en.wikipedia.org/wiki/Skew-symmetric_graph "Skew-symmetric graph").
-   [Topologically order](https://en.wikipedia.org/wiki/Topological_sorting "Topological sorting") the vertices of the condensation. In practice this may be efficiently achieved as a side effect of the previous step, as components are generated by Kosaraju's algorithm in topological order and by Tarjan's algorithm in reverse topological order. [[Topological sort]]
-   For each component in the reverse topological order, *if its variables do not already have truth assignments, set all the literals in the component to be true.* This also causes all of the literals in the complementary component to be set to false.

Due to the reverse topological ordering and the skew-symmetry, when a literal is set to true, all literals that can be reached from it via a chain of implications will already have been set to true. Symmetrically, when a literal _x_ is set to false, all literals that lead to it via a chain of implications will themselves already have been set to false. Therefore, the truth assignment constructed by this procedure satisfies the given formula, which also completes the proof of correctness of the necessary and sufficient condition identified by Aspvall et al.

As Aspvall et al. show, a similar procedure involving topologically ordering the strongly connected components of the implication graph may also be used to evaluate [fully quantified Boolean formulae](https://en.wikipedia.org/wiki/True_quantified_Boolean_formula "True quantified Boolean formula") in which the formula being quantified is a 2-CNF formula.