---
aliases: IV, SV, starting variable
tags: 50.042
---
[[50.042 Foundations of Cybersecurity|50.042]]

## What
> An input to a cryptographic primitive being used to provide the initial state.

Typically required to be random or pseudorandom, but sometimes only needs to be unpreditable or unique.

Randomisation is crucial for some encryption schemes to achieve semantic security, a property whereby repeated usage of the scheme under the same key does not allow an attacker to infer relationships between (potentially similar) segments of the encrypted message. For [[Block ciphers]], the use of an IV is described by the modes of operation.

Some cryptographic primitives require the IV only to be non-repeating, and the required randomness is derived internally. In this case, the IV is commonly called a [[nonce]], and the primitives (e.g. [[Cipher-Block-Chaining mode (CBC)|CBC]]) are considered *stateful* rather than *randomised*. This is because an IV need not be explicitly forwarded to a receipient but may be derived from a common state updated at both sender and receiver sde (in practice, a short [[nonce]] is still transmitted along with the message to consider message loss). An example of stateful encryption schemes is the [[Counter-mode CTR]], which has a **sequence number** for a [[nonce]].

The IV size depends on the cryptographic primitive used; for [[Block ciphers]] it is generally the cipher's block-size. When the IV is chosen at random, the probability of [[Intro to hashing|collisions]] due to the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem "Birthday problem") must be taken into account. Some designs realized in practice are known to be insecure; the [WEP](https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy "Wired Equivalent Privacy") protocol is a notable example, and is prone to related-IV attacks.

## Motivation
To hide patterns in encrypted data while avoiding the re-issuing of a new key after each [[Block ciphers]] invocation, a method is needed to [randomize](https://en.wikipedia.org/wiki/Randomization "Randomization") the input data. In 1980, the [NIST](https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology "National Institute of Standards and Technology") published a national standard document designated [Federal Information Processing Standard](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard "Federal Information Processing Standard") (FIPS) PUB 81, which specified four so-called [block cipher modes of operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation "Block cipher mode of operation"), each describing a different solution for encrypting a set of input blocks. The first mode implements the simple strategy described above, and was specified as the [electronic codebook](https://en.wikipedia.org/wiki/Electronic_codebook "Electronic codebook") ([[Electronic Code Book (ECB)|ECB]]) mode. In contrast, each of the other modes describe a process where ciphertext from one block encryption step gets intermixed with the data from the next encryption step. To initiate this process, an additional input value is required to be mixed with the first block, and which is referred to as an _initialization vector_. For example, the [cipher-block chaining](https://en.wikipedia.org/wiki/Cipher-block_chaining "Cipher-block chaining") ([[Cipher-Block-Chaining mode (CBC)|CBC]]) mode requires an unpredictable value, of size equal to the cipher's block size, as additional input. This unpredictable value is added to the first plaintext block before subsequent encryption. In turn, the ciphertext produced in the first encryption step is added to the second plaintext block, and so on. The ultimate goal for encryption schemes is to provide [semantic security](https://en.wikipedia.org/wiki/Semantic_security "Semantic security"): by this property, it is practically impossible for an attacker to draw any knowledge from observed ciphertext. It can be shown that each of the three additional modes specified by the NIST are semantically secure under so-called [chosen-plaintext attacks](https://en.wikipedia.org/wiki/Chosen-plaintext_attack "Chosen-plaintext attack").

## Properties
Properties of an IV depend on the cryptographic scheme used. A basic requirement is **uniqueness**, which means that ==no IV may be reused under the same key==. For [[Block ciphers]], repeated IV values devolve the encryption scheme into [[Electronic Code Book (ECB)]]: equal IV and equal plaintext result in equal ciphertext. In [stream cipher](https://en.wikipedia.org/wiki/Stream_cipher "Stream cipher") [[Stream ciphers]] encryption uniqueness is crucially important as plaintext may be trivially recovered otherwise.

_**Example:**_ Stream ciphers encrypt plaintext $P$ to ciphertext $C$ by deriving a key stream $K$ from a given key and IV and computing $C$ as $C = P \oplus K$. Assume that an attacker has observed two messages $C_1$ and $C_2$ both encrypted with the same key and IV. Then knowledge of either $P_1$ or $P_2$ reveals the other plaintext since

$C_1 \oplus C_2 = (P_1 \oplus K) \oplus (P_2 \oplus K) = P_1 \oplus P_2$

Many schemes require the IV to be _unpredictable_ by an [adversary](https://en.wikipedia.org/wiki/Adversary_(cryptography) "Adversary (cryptography)"). This is effected by selecting the IV at [random](https://en.wikipedia.org/wiki/Random "Random") or [pseudo-randomly](https://en.wikipedia.org/wiki/Pseudo-random "Pseudo-random"). In such schemes, the chance of a duplicate IV is [negligible](https://en.wikipedia.org/wiki/Negligible_function "Negligible function"), but the effect of the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem "Birthday problem") must be considered. As for the uniqueness requirement, a predictable IV may allow recovery of (partial) plaintext.

_**Example:**_ Consider a scenario where a legitimate party called Alice encrypts messages using the cipher-block chaining mode. Consider further that there is an adversary called Eve that can observe these encryptions and is able to forward plaintext messages to Alice for encryption (in other words, Eve is capable of a [chosen-plaintext attack](https://en.wikipedia.org/wiki/Chosen-plaintext_attack "Chosen-plaintext attack")). Now assume that Alice has sent a message consisting of an initialization vector $IV_1$ and starting with a ciphertext block $C_{Alice}$. Let further $P_{Alice}$ denote the first plaintext block of Alice's message, let $E$ denote encryption, and let $P_{Eve}$ be Eve's guess for the first plaintext block. Now, if Eve can determine the initialization vector $IV_2$ of the next message she will be able to test her guess by forwarding a plaintext message to Alice starting with $(IV_2 \oplus IV_1 \oplus P_{Eve})$; if her guess was correct this plaintext block will get encrypted to $C_{Alice}$ by Alice. This is because of the following simple observation:

$C_{Alice} = E(IV_1 \oplus P_{Alice}) = E(IV_2 \oplus (IV_2 \oplus IV_1 \oplus P_{Alice})$

Depending on whether the IV for a cryptographic scheme must be random or only unique the scheme is either called _randomized_ or _stateful_. While randomized schemes always require the IV chosen by a sender to be forwarded to receivers, stateful schemes allow sender and receiver to share a common IV state, which is updated in a predefined way at both sides.
